// Copyright 2019 Authors of Cilium
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package elf

import (
	"debug/elf"
	"encoding/binary"
	"fmt"
	"io"
	"os"
	"unsafe"

	"github.com/cilium/cilium/pkg/logging/logfields"
)

// ELF is an in-memory representation of a BPF ELF object from the filesystem.
type ELF struct {
	*elf.File

	symbols Symbols
	path    string
	file    *os.File // TODO: Make this buffered with a shared buffer?
}

// newElf reads the ELF at the specified path.
func newELF(f *os.File, path string) (*ELF, error) {
	ef, err := elf.NewFile(f)
	if err != nil {
		return nil, &os.PathError{
			Op:   "unable to open ELF",
			Path: path,
			Err:  err,
		}
	}

	// EM_NONE machine type is generated by older versions of Clang.
	if ef.Machine != elf.EM_NONE && ef.Machine != elf.EM_BPF {
		return nil, &os.PathError{
			Op:   "unable to parse ELF",
			Path: path,
			Err:  fmt.Errorf("unsupported machine type %s", ef.Machine),
		}
	}

	result := &ELF{
		File: ef,
		file: f,
		path: path,
	}
	if err := result.symbols.extractFrom(result); err != nil {
		return nil, &os.PathError{
			Op:   "unable to read ELF symbols",
			Path: path,
			Err:  err,
		}
	}

	return result, nil
}

// Open the ELF file at the specified path for reading.
// The caller must eventually make the corresponding call to Close().
func Open(path string) (*ELF, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}

	result, err := newELF(f, path)
	if err != nil {
		f.Close()
	}
	return result, err
}

// Close the ELF file. The caller should no longer use this ELF.
func (e *ELF) Close() error {
	return e.file.Close()
}

func (elf *ELF) readValue(offset int64, size uint64) ([]byte, error) {
	if _, err := elf.file.Seek(int64(offset), io.SeekStart); err != nil {
		return nil, err
	}
	result := make([]byte, size)
	if err := binary.Read(elf.file, elf.ByteOrder, &result); err != nil {
		return nil, err
	}
	if _, err := elf.file.Seek(0, io.SeekStart); err != nil {
		return nil, err
	}
	return result, nil
}

func (elf *ELF) readOption(key string) (result uint32, err error) {
	opt, exists := elf.symbols.data[key]
	if !exists {
		return 0, fmt.Errorf("no such option %q in ELF", key)
	}
	value, err := elf.readValue(int64(opt.offset), opt.size)
	if err != nil {
		return 0, err
	}
	return elf.ByteOrder.Uint32(value), err
}

func (elf *ELF) findString(key string) error {
	opt, exists := elf.symbols.strings[key]
	if !exists {
		return fmt.Errorf("no such string %q in ELF", key)
	}
	if _, err := elf.readValue(int64(opt.offset), opt.size); err != nil {
		return err
	}
	return nil
}

// copy the ELF from the reader to the writer, substituting the constants with
// names specified in 'intOptions' with their corresponding values, and the
// strings specified in 'strOptions' with their corresponding values.
//
// Keys in the 'intOptions' / 'strOptions' maps are case-sensitive.
func (e *ELF) copy(w io.Writer, r io.ReadSeeker, intOptions map[string]uint32, strOptions map[string]string) error {
	if len(intOptions) > 0 || len(strOptions) > 0 {
		globalOff := uint64(0) // current position in file

		for _, symbol := range e.symbols.sort() {
			scopedLog := log.WithField("symbol", symbol.name)

			// Figure out the value to substitute
			var value []byte
			switch symbol.kind {
			case symbolUint32:
				v, exists := intOptions[symbol.name]
				if exists {
					value = make([]byte, unsafe.Sizeof(v))
					e.ByteOrder.PutUint32(value, v)
				}
			case symbolString:
				v, exists := strOptions[symbol.name]
				if exists {
					if uint64(len(v)) != symbol.size {
						return fmt.Errorf("symbol substitution value %q (len %d) must equal length of symbol name %q (len %d)", v, len(v), symbol.name, len(symbol.name))
					}
					value = []byte(v)
				}
			}
			if value == nil {
				scopedLog.Warning("Skipping symbol substitution")
				continue
			}

			// Copy data up until this symbol into the new file;
			// Write the new value and seek past it.
			dataToCopy := int64(symbol.offset - globalOff)
			if _, err := io.CopyN(w, r, dataToCopy); err != nil {
				return err
			}
			if err := binary.Write(w, e.ByteOrder, value); err != nil {
				return fmt.Errorf("failed to substitute %s: %s", symbol.name, err)
			}
			if _, err := r.Seek(int64(symbol.size), io.SeekCurrent); err != nil {
				return err
			}
			globalOff = symbol.offset + symbol.size
		}
	}

	// Copy the remaining portion of the file
	if _, err := io.Copy(w, r); err != nil {
		return err
	}

	return nil
}

// Write the received ELF to a new file at the specified location, with the
// specified options (indexed by name) substituted in the data section.
// On success, writes the file to the specified path. On failure, returns an
// error and no file is left on the filesystem.
//
// Concurrent writes from the same source ELF is NOT safe.
func (e *ELF) Write(path string, intOptions map[string]uint32, strOptions map[string]string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}

	err = e.copy(f, e.file, intOptions, strOptions)
	if err == nil {
		err = f.Sync()
	}
	if _, err2 := e.file.Seek(0, io.SeekStart); err2 != nil {
		log.WithField(
			logfields.Path, e.path,
		).Warning("Failed to seek to beginning of ELF")
	}

	f.Close()
	if err != nil {
		if err2 := os.RemoveAll(path); err2 != nil {
			log.WithField(
				logfields.Path, path,
			).WithError(err).Warning("Failed to clean up path on error")
		}
	}
	log.WithField(logfields.Path, path).WithError(err).Debugf("Finished copying ELF from %s", e.path)
	return err
}
